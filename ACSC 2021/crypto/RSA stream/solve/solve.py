#!/usr/bin/env python

# Work with both python2 and python3

import gmpy2
from Crypto.Util.number import long_to_bytes, bytes_to_long, getStrongPrime, inverse

n = 30004084769852356813752671105440339608383648259855991408799224369989221653141334011858388637782175392790629156827256797420595802457583565986882788667881921499468599322171673433298609987641468458633972069634856384101309327514278697390639738321868622386439249269795058985584353709739777081110979765232599757976759602245965314332404529910828253037394397471102918877473504943490285635862702543408002577628022054766664695619542702081689509713681170425764579507127909155563775027797744930354455708003402706090094588522963730499563711811899945647475596034599946875728770617584380135377604299815872040514361551864698426189453

with open("chal.py", "rb") as f:
    chal = f.read()

with open("chal.enc", "rb") as f:
    enc = f.read()

q1 = bytes_to_long(chal[:256])
c1 = q1 ^ bytes_to_long(enc[:256])
e1 = 65537

q2 = bytes_to_long(chal[256:512])
c2 = q2 ^ bytes_to_long(enc[256:512])
e2 = gmpy2.next_prime(e1)

_, a, b = gmpy2.gcdext(e1, e2)
m = (gmpy2.powmod(c1, a, n) * gmpy2.powmod(c2, b, n)) % n
print(long_to_bytes(m))

# ACSC{changing_e_is_too_bad_idea_1119332842ed9c60c9917165c57dbd7072b016d5b683b67aba6a648456db189c}