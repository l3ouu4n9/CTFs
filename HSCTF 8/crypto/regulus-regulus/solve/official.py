#!/usr/bin/env python3

import random
from fractions import Fraction
from math import gcd
from ecdsa.numbertheory import inverse_mod

def outputPrimes(a, n):
    p = gcd(a, n)
    q = int(n // p)
    if p > q:
        p, q = q, p
    return p, q

def RecoverPrimeFactors(n, e, d):
    k = d * e - 1
    if k % 2 == 1:
        failFunction()
        return 0, 0
    else:
        t = 0
        r = k
        while(r % 2 == 0):
            r = int(r // 2)
            t += 1
        for i in range(1, 101):
            g = random.randint(0, n) # random g in [0, n-1]
            y = pow(g, r, n)
            if y == 1 or y == n - 1:
                continue
            else:
                for j in range(1, t): # j \in [1, t-1]
                    x = pow(y, 2, n)
                    if x == 1:
                        p, q = outputPrimes(y - 1, n)
                        return p, q
                    elif x == n - 1:
                        continue
                    y = x
                    x = pow(y, 2, n)
                    if  x == 1:
                        p, q = outputPrimes(y - 1, n)
                        return p, q
e = 65537
n = 21287346547916416171791071126484391269023181920216317893856775376637573351138475499691197163743826840704451410886551262909196422570492844311301491357051432821467300636101662634918845092557800128572047437310491917009434567315253793223844997673694854072031994844543403267447813748070554941839095896470400513955168901162865216374444467536780369184652013200850800937061482195034698905679072060977246152052268868290143801512448773655721088507736228212328635265102852103185076592347955532443814287739573684868597168696143043985531658878246519368740336050892072083743256346556069277803857073123911894024936817578641663666719
d = 19035734690947732879866574963266822563149115407087253157292465644564825766261353993307637056642918839731516165448621950391282120706528116039242319620672280093719443272941055262209422412520406435066677450349899732919387717129414659686641684676852570653088103786631462356970552889294213533827917283559635352859079887716528348664942633685287841577113163237972494443265850052493656682700750305254584923009403765890439345535181795565133385886418531728222128514771932365091272249414015745918066635770058402789505809670248250558006698045491793795013408392817213837403368284019400533502619594456758810603607178641977423975273
p, q = (RecoverPrimeFactors(n, e, d))
n = p * q
phi = (p-1) * (q-1)
d = inverse_mod(e, phi)
if (d + phi // 2) > n:
    print(d - phi // 2)
else:
    print(d + phi // 2)

# Send second private key
# 8392061416989524793971039400024626928637524446979094210364077956246039090692116243462038474771005419379290460005346318936683909421281693883591573942146563682985792954890223944749999866241506370780653731694653774414670433471787763074719185840005143617072106364359760723246646015258936062908369335324435095881641797099020299979213213125329567765669895776774615692917637315608776740595477096863920883257955130064471225167131208277767574856316908028260575435063646967847123205733046972432593270797254738054279785880818512508180872861570663431189555941319374546712262173365194810747213226724375889602595288302763411219813
# flag{r3gulus_regu1us_regUlus_regulu5_regUlus_Regulus_reguLus_regulns_reGulus_r3gulus_regu|us}