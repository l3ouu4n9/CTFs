#!/usr/bin/python3.8

import base64
import json
import re
from datetime import datetime as dt
from itertools import chain
import requests
from typing import List

TARGET_URL = "http://pwn.osucyber.club:13377"

def split_blocks(data: bytes, blocksize: int = 16) -> List[bytes]:
	return [data[s : s + blocksize] for s in range(0, len(data), blocksize)]

def merge_blocks(blocks: List[bytes]) -> bytes:
	return bytes(chain.from_iterable(blocks))

def xor_blocks(block1: bytes, block2: bytes) -> bytes:
	return bytes(b1 ^ b2 for b1, b2 in zip(block1, block2))

def pkcs7(data: bytes, blocksize: int = 16) -> bytes:
	d = bytearray(data)
	padding_len = blocksize - len(d) % blocksize
	d.extend(padding_len for _ in range(padding_len))
	return bytes(d)


def get_cookie(name: str) -> str:
	res = requests.post(f"{TARGET_URL}/login", {"username": name}, allow_redirects=False)
	cookies = {c.name: c.value for c in res.cookies}
	return cookies.get('SESSIONID3', None)

def test_padding(iv: bytes, block: bytes) -> bool:
	cookie = base64.b64encode(merge_blocks([iv, block])).decode('ascii')

	res = requests.get(f"{TARGET_URL}/flag", cookies={'SESSIONID3': cookie}, allow_redirects=False)
	if res.headers.get('Location', '').endswith('err=Error+parsing+session'):
		return True
	elif res.headers.get('Location', '').endswith('err=Invalid+Padding'):
		return False
	else:
		return None


def make_test_iv(iv: bytes, cleartext: bytes, test_byte: int, pos: int) -> bytes:
	test_cleartext = bytearray(cleartext)
	test_cleartext[pos] = test_byte

	return bytes(iv[k] ^ test_cleartext[k] ^ (16 - pos) for k in range(16))

def decrypt_byte(iv: bytes, block: bytes, pos: int, cleartext: bytes) -> List[int]:
	test_ivs = [(test_byte, make_test_iv(iv, cleartext, test_byte, pos)) for test_byte in range(256)]

	return [test_byte for test_byte, iv in test_ivs if test_padding(iv, block)]


def decrypt_block(iv, block, num_bytes=16):
	cleartext = bytearray(b'\x00' * 16)

	options = [[] for _ in range(16)]

	for i in reversed(range(16-num_bytes, 16)):
		print(i)
		options[i] = decrypt_byte(iv, block, i, cleartext)

		if not options[i]:
			# If we cannot find valid decryption
			cleartext[i + 1] = options[i + 1].pop()
			options[i] = decrypt_byte(iv, block, i, cleartext)

		cleartext[i] = options[i].pop()
		print(chr(cleartext[i]), end='')

	print()
	return bytes(cleartext[16-num_bytes:])

def decrypt_cookie(cookie: bytes) -> bytes:
	blocks = split_blocks(cookie)
	cleartext = bytearray()

	for i in range(1, len(blocks)):
		print(f"{i}: ", end='')
		cleartext.extend(decrypt_block(blocks[i - 1], blocks[i]))
	return bytes(cleartext)

def get_flag(cookie: str) -> str:
	res = requests.get(f"{TARGET_URL}/flag", cookies={'SESSIONID3': cookie}, allow_redirects=False)
	return re.findall(r'osuctf{.*}', res.text)

if __name__ == '__main__':
	# By testing names of different lengths, we can figure out that the secret string is four bytes long.
	# Using name "AAAAAAAAAA" (10) gives a cookie four blocks long, and "AAAAAAAAAAA" (11) gives a cookie five blocks long,
	# so we know that the uncontrolled portion of the cookie is 53 bytes long (4 blocks = 64 bytes, 1 byte for padding 
	# and 10 bytes for the name leaves 53 bytes) Counting up the IV and the rest of the characters we know in
	# the JSON leaves four bytes for the secret string

	# IVIVIVIVIVIVIVIV{"name":"AAAAAAAAAA","q":"####","role":"users"}P
	# IVIVIVIVIVIVIVIV{"name":"AAAAAAAAAAA","q":"####","role":"users"}PPPPPPPPPPPPPPPP
	# #------IV------##-------1------##-------2------##-------3------##-------4------#


	# IVIVIVIVIVIVIVIV{"name":"AAAAAAAAAAAA","q":"####","role":"users"}PPPPPPPPPPPPPPP
	# #------IV------##-------1------##-------2------##-------3------##-------4------#
	# IVIVIVIVIVIVIVIV{"q":"####","":"????????????????","role":"admin"}PPPPPPPPPPPPPPP

	start = dt.now()
	print(f"Started: {start.strftime('%Y-%m-%d %H:%M:%S')}")

	cookie = base64.b64decode(get_cookie("AAAAAAAAAAAA"))
	
	blocks = split_blocks(cookie)
	
	# 1337
	secret_val = decrypt_block(blocks[1], blocks[2], 4)

	print(f"SUPER_SECRET_STRING: {secret_val}")
	
	for i in range(100):
		print(".", end='')
		cookie = base64.b64decode(get_cookie("AAAAAAAAAAAA"))

		blocks = split_blocks(cookie)

		diff1 = xor_blocks(b'{"name":"AAAAAAA', b'{"q":"' + secret_val + b'","":"')
		diff3 = xor_blocks(b'","role":"users"', b'","role":"admin"')


		blocks[0] = xor_blocks(blocks[0], diff1)
		blocks[2] = xor_blocks(blocks[2], diff3)

		new_cookie = base64.b64encode(merge_blocks(blocks)).decode('ascii')
		if flags := get_flag(new_cookie):
			print(f"\nCookie: {new_cookie}")
			print(*flags, sep='\n')
			break

	finish = dt.now()
	print(f"\nFinished: {finish.strftime('%Y-%m-%d %H:%M:%S')}")
	print(f"Elapsed: {finish - start}")








